# Kustomize Problem Statement & idealogy
# Kustomize vs Helm 
# Installation/Setup  
# kustomization.yaml file  
# Kustomize Output  
# Kustomize ApiVersion & Kind  
# Managing Directories  
# Managing Directories Demo  
# Common Transformers  
# Image Transformers  
# Transformers Demo  
# Patches Intro  
# Different Types of Patches  
# Patches Dictionary  
# Patches list  
# Overlays  
# Components  



# Kustomize Problem Statement & idealogy

 Before we get started taking a look at what Kustomize is and how to use it, let us first go over what problems it tries to address and why it was ultimately created.  

Consider a simple example. We have an nginx deployment YAML file that deploys a single nginx pod. Now, imagine we have multiple environments: one for development on a local machine, one for staging, and one for production. We may want to customize the deployment so it behaves differently in each environment. For instance, in development we may want only one replica, in staging two to three replicas, and in production, which handles higher traffic, five to ten replicas.  

The challenge is how to modify configurations on a per-environment basis. With a single nginx deployment YAML, the same replica count applies everywhere. A simple solution is to create three separate directories: one each for development, staging, and production. Each directory holds the Kubernetes configs for that environment. This means duplicating configs across directories and modifying only the parameters that differ, such as replicas. In practice, dev might have replicas set to 1, staging to 2, and production to 5.  

To apply these, you would run `kubectl apply` on the desired directory. This works fine for small deployments. However, as the number of resources grows, this solution becomes harder to maintain. For example, adding a new `service.yaml` requires copying it to all directories. Similarly, any updates must be replicated across environments. With multiple environments, it’s easy to forget changes, leading to mismatched configurations. This duplication and maintenance overhead is precisely why Kustomize was created.  

Kustomize provides a better solution by allowing customization of environments without duplicating all configuration files. The goal is to reuse Kubernetes configs and modify only what differs per environment, rather than copying entire manifests.  

Kustomize works around two key concepts: **base** and **overlays**.  

The **base** contains configurations that are identical across all environments. It may also define default values. For example, an nginx deployment with replicas set to 1 could be the base config. The base ensures consistency while providing defaults that overlays can override.  

The **overlays** represent environment-specific customizations. You can create an overlay for each environment and specify only the properties that differ from the base. In our example, staging overrides replicas to 2, and production overrides replicas to 5. The development environment requires no overlay because it already matches the default in the base.  

The folder structure reflects this approach. A `base` directory contains shared configs, while an `overlays` directory contains subfolders for each environment. Each overlay folder holds overrides or additional resources specific to that environment. Kustomize then combines the base and overlays to generate the final Kubernetes manifest, which can be applied to the cluster.  

One of the advantages of Kustomize is that it comes built into `kubectl`, so no separate installation is required. However, the bundled version may not always be the latest, so in some cases installing Kustomize separately is recommended.  

Unlike Helm, Kustomize does not rely on a templating system. Everything is plain YAML. You define bases and overlays in YAML, and Kustomize merges them. This keeps configurations simple and readable. Helm charts, by contrast, can become difficult to interpret due to complex templating.  

Because Kustomize uses only YAML, manifests remain fully valid and can be processed like any other Kubernetes resource file. There is no special syntax or language to learn. This simplicity is one of the greatest strengths of Kustomize—it focuses on reusability and clarity without introducing unnecessary complexity.

# Kustomize vs Helm  
Before moving on to the next section, it is important to briefly discuss an alternative tool to Kustomize: Helm. Understanding Helm at a high level helps us compare how it addresses the same problem of customizing Kubernetes manifests on a per-environment basis. Having insight into both tools, along with their pros and cons, allows you to make a more informed decision when choosing the best tool for your project.  

Helm tackles this issue by using the Go templating syntax to define variables within manifests. In a Helm template, you may notice unusual syntax with double curly braces and a variable name inside, such as `{{ .Values.replicaCount }}`. Instead of hardcoding values like replicas or image tags, Helm uses these variables so that values can be supplied later.  

Values are provided through a `values.yaml` file. For example, the variable `replicaCount` in the deployment manifest would reference a property of the same name in `values.yaml`. If `replicaCount` is set to 1 in the file, Helm inserts this value when deploying. Similarly, an image tag defined as a variable in the template is resolved through the `values.yaml` file, where you might specify `2.4.4` as the tag.  

A typical Helm project structure reflects this design. Under the `templates` directory, all Kubernetes manifests are stored, but instead of fixed values, they contain variables using Go templating syntax. Alongside templates, separate values files can exist for different environments, such as `values.dev.yaml`, `values.staging.yaml`, and `values.prod.yaml`. These files define environment-specific values, and when deploying, you simply specify which values file Helm should use. Helm then inserts the correct values into the templates for that environment.  

It is important to note that Helm is more than just an environment customization tool. It functions as a full-fledged package manager for Kubernetes applications, similar to how `apt` or `yum` operate for Linux systems. This means Helm also provides advanced functionality such as conditionals, loops, functions, and hooks, giving it capabilities beyond simple templating.  

However, this added functionality comes at the cost of complexity. Helm templates are not plain YAML because of the Go templating syntax. As a result, many Helm charts can be difficult to read since most values are abstracted into variables. It may not always be clear what a chart does or which values you can modify without digging into both templates and values files.  

This complexity is one of the reasons why some prefer Kustomize. With Kustomize, everything is plain YAML, making it easy to read and understand. Base configurations are standard Kubernetes manifests, and overlays are also valid YAML files. This simplicity makes Kustomize very approachable and transparent.  

Ultimately, the trade-off between Helm and Kustomize comes down to simplicity versus functionality. Kustomize is easier to use and read, while Helm provides more features but introduces additional complexity. Choosing between them depends on the needs of your project and the level of flexibility or simplicity you value most.

# Installation/Setup  


# kustomization.yaml file  
Now that Kustomize is installed and configured, we can start working with it. The first thing to understand is the `kustomization.yaml` file—what it is, why we need it, and how to configure it.  

In a typical setup, we might have a directory (e.g., `k8s/`) containing Kubernetes manifests, such as `nginx-deployment.yaml` and `nginx-service.yaml`. However, Kustomize does not directly read these YAML files. Instead, it looks for a single file named `kustomization.yaml`. This file must be created manually and must have that exact name.  

The `kustomization.yaml` file has two main sections:  

1. **Resources:**  
   - A list of all Kubernetes resources (YAML files) that Kustomize should manage.  
   - In this example, `nginx-deployment.yaml` and `nginx-service.yaml` are listed under `resources`.  

2. **Transformations / Customizations:**  
   - Any modifications or transformations we want to apply to the resources.  
   - Example: adding a common label `company: KodeKloud` to all resources.  
   - There are many types of transformations available, but this example demonstrates a simple label addition.  

Once the `kustomization.yaml` file is configured, we use the `kustomize build` command to generate the final configuration.  

- The command is pointed to the directory containing `kustomization.yaml`.  
- Kustomize reads the listed resources and applies all defined transformations.  
- The output shows the complete configuration, including any transformations (e.g., added labels).  

Important points:  

- Running `kustomize build` **does not deploy** resources to the Kubernetes cluster. It only outputs the final manifests to the terminal.  
- To actually deploy these resources, we need to pipe the output to `kubectl apply` (e.g., `kustomize build ./k8s | kubectl apply -f -`).  
Summary:
- Kustomize relies on a `kustomization.yaml` file.  
- The file contains:  
  1. A list of resources to manage.  
  2. The transformations or customizations to apply.  
- `kustomize build` combines resources and transformations to produce the final manifests.  
- Deployment to the cluster requires redirecting the output to `kubectl apply`.  

# Kustomize Output  

# Kustomize ApiVersion & Kind  
# Managing Directories  
# Managing Directories Demo  
# Common Transformers  
# Image Transformers  
# Transformers Demo  
# Patches Intro  
# Different Types of Patches  
# Patches Dictionary  
# Patches list  
# Overlays  
# Components  
