# Hem introduction
In this section, we will talk about Helm.

Kubernetes is excellent at managing complex infrastructures. However, humans tend to struggle with complexity, and applications deployed into Kubernetes clusters can quickly become complicated. A typical application is usually made up of a collection of objects that must interconnect to work properly.

For example, even a relatively simple WordPress site might require a Deployment to declare the Pods you want to run, such as a MySQL database server or web servers. It will also need a PersistentVolume to store the database, a PersistentVolumeClaim to request storage, a Service to expose the web server running in a Pod, and a Secret to store the admin password. On top of this, you may add even more objects, like jobs for periodic backups. Each object typically has its own YAML file, and we need to run `kubectl apply` for each one.

This can quickly become tedious. Imagine downloading YAML files for such an app from the internet and then realizing you don’t like the defaults. For example, the PersistentVolume may be set to 20 GB, but you know your website needs 100 GB. You would have to open the YAML file for PersistentVolumes and edit it. If there are many such changes, you must repeat this process across multiple YAML files.  

Two months later, you might need to upgrade some components. Once again, you would have to carefully edit multiple YAML files. Or, if you need to delete the application, you must remember every object belonging to it and delete them one by one. Some might argue that writing all object definitions in a single YAML file would help. While possible, this could make things worse—imagine searching for a specific setting in a 25-page-long YAML file.

This is where **Helm** comes in. Helm changes the paradigm. Kubernetes itself doesn’t recognize the concept of an "application." It only knows about individual objects like Deployments, Services, and PersistentVolumes, and manages them separately. Kubernetes doesn’t understand that all these objects together make up something like a WordPress app. Helm, however, is designed to handle exactly this problem, which is why it’s often called a **package manager for Kubernetes**.

Helm treats groups of related Kubernetes objects as a single package. When we want to perform an action, we don’t need to specify individual objects. We just tell Helm to act on the package (e.g., our WordPress app), and Helm automatically manages all the underlying objects, even if there are hundreds of them.

Think of it like installing a computer game. A game contains thousands of files—program executables, images, audio, configurations, and more. If we had to manually download each file separately, it would be painful. Thankfully, we don’t have to; we simply run an installer. The installer puts every file in the correct location. Helm works the same way for Kubernetes applications. It acts as an installer for the YAML files and Kubernetes objects that form an application.

With Helm, we get several advantages. We can install an entire application using a single command, even if it requires hundreds of objects. Helm automatically creates all the necessary Kubernetes resources. We can also customize our applications easily. Instead of editing multiple YAML files, we specify custom values in a single file called `values.yaml`. This is where we can adjust the PersistentVolume size, set the admin password, or configure database engine settings.

Upgrading applications is also simplified. With a single command, Helm knows which objects to update. If needed, we can roll back to a previous version (called a revision) with another single command. Similarly, uninstalling an app is straightforward. Helm keeps track of all objects created for each application, so when we uninstall, it removes everything automatically—no need to remember every object or issue multiple delete commands.

In short, Helm acts as both a **package manager** (like an installer/uninstaller wizard) and a **release manager** (handling upgrades and rollbacks). The core idea is that Helm lets us treat our Kubernetes workloads as full applications instead of a scattered collection of objects. This greatly reduces complexity and removes the need to micromanage every single resource.

In the upcoming lectures, we will explore Helm commands in more detail. For now, remember that Helm is a powerful tool that helps us install, upgrade, roll back, and uninstall Kubernetes applications with ease.


# install helm
Let us now talk about installing Helm.

Before installing Helm, you must first have a functional Kubernetes cluster and the `kubectl` utility installed and configured on your local computer. This means that the correct credentials or login details must already be set up in your kubeconfig file so that `kubectl` can connect to the intended Kubernetes cluster. In short, you need to make sure that `kubectl` is properly configured to work with the cluster you plan to use Helm on.
Helm itself can be installed on Linux, Windows, or macOS systems. For now, we will focus on the installation steps for Linux.
On Linux systems with the **snap** utility installed, Helm can be installed using the following command:
* snap install helm --classic

The `--classic` parameter is important because it installs Helm with a more relaxed sandbox environment. This gives Helm additional access to the host system rather than being strictly isolated. For example, it allows Helm to access the kubeconfig file in your home directory so it knows how to connect to your Kubernetes cluster.
For **APT-based systems** such as Debian or Ubuntu, you must first add the Helm GPG key and the official Helm repository to your sources list before running the install command. The process typically involves downloading the key, adding the repository, updating your package lists, and then installing Helm using:
* sudo apt-get install helm


For **RPM-based systems** such as Fedora, CentOS, or Red Hat, you can install Helm using the package manager:
* sudo yum install helm or sudo dnf install helm

depending on your system.
Finally, always remember to refer to the official Helm documentation for the latest installation instructions that match your operating system and version. The documentation is regularly updated and provides step-by-step guidance for Linux, Windows, and macOS installations.

# Helm concept
Let us now understand the Helm concepts.

So back to our WordPress application. We have now discussed about the challenges. Let us now see how Helm solves these challenges using charts.

Here are the YAML files that we plan to use. We have the deployment.yaml, the secret.yaml, the PVC.yaml, and the service.yaml. Each file has its own definition to deploy a component of the WordPress application on Kubernetes.

Now we know that some of these have values that might change between different environments. Users may prefer to use a different version of the WordPress image that is used to deploy the WordPress application, or a different size of disk. And of course, the WordPress admin password is going to be different as well.

So the first step is to convert these files into templates where these values become variables. The two curly braces indicate that these are variables, and the values specified within are variable names which will be used to fetch these values from another place.

So what is that other place where these values are fetched from? These values are stored in a file named values.yaml. This file has the image, storage, and password variables defined with the values we want these to have.

This way, anyone who wants to deploy this application can customize their deployment by simply changing the values from the single file called values.yaml. A combination of templates plus values.yaml gives us the final version of definition files that can be used to deploy the application on the Kubernetes cluster.

Together, the templates and the values file form a Helm chart. A single Helm chart may be used to deploy a simple application like WordPress in our example, and it will have all the necessary template files for different services as well as the values file with the variables.

It also has a chart.yaml file that has information about the chart itself, such as the name of the chart, the chart’s version, a description of what the chart is, some keywords associated with the application, and information about the maintainers.

Now you can create your own chart for your own application, or you can explore existing charts from the Artifact Hub at artifacthub.io and look for charts uploaded by other users. This hub is called a repository that stores Helm charts. As of this recording, there are over 5,700 charts available. Search for a chart for the application you are trying to deploy.

You can either search using this web interface, or you can search using the command:
* helm search hub


This indicates that you wish to search the Artifact Hub. The Artifact Hub is the community-driven chart repository, but there are other repositories as well, such as the Bitnami Helm repository.
To search for charts in other repositories, you must first add a repository to your local Helm setup. For this, run the command:
* helm repo add


to add the Bitnami repository with the link to the Bitnami charts repository. Then search the repository using the `helm search repo` command instead of the `helm search hub` command. You can also list existing repos using the `helm repo list` command.

Now, once you find the chart, the next step is to install the chart on your cluster. For this, run the `helm install` command followed by a release name and the chart name. When this command is run, the Helm chart package is downloaded from the repository, extracted, and installed locally.

Each installation of a chart is called a release, and each release has a release name. That’s the release name you specify within the `helm install` command. For example, you can install the same application using the same chart multiple times on a Kubernetes cluster by running the `helm install` command multiple times. Each time you run it, a release is created, and each release is completely independent of each other.

Let’s proceed to some additional Helm commands. To list installed packages, run the `helm list` command. To uninstall packages, run the `helm uninstall` command.

Now, we saw that we could use the `helm install` command to download and install a Helm chart. But if we only need to download it and not install it, then run the `helm pull` command. Use the `--untar` option because the chart is normally downloaded in a `.tar` archive format. The `--untar` option will extract its contents after downloading it.

Once extracted, you can find the contents of the chart. When you list the files under the extracted folder, it will be in the same name as the chart. You may open and edit the values.yaml file to change any values if required.

Now, once the changes are made, install the local chart using the `helm install` command but by specifying the path to that particular directory.

So that is all that we will be discussing about Helm in this course. There is so much to learn about Helm, and it requires an entire course of its own. We are working on an entire course on Helm for beginners, and we will be releasing that soon. So watch out for that.

From an exam perspective, we have already covered what is required for you to know. So head over to the labs and practice working on Helm.





